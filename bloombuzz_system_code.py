# -*- coding: utf-8 -*-
"""BloomBuzz Correct DataSet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vi7UwWBabbZmusXBnw-THkdhDbY-UC-n
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd

file_name = list(uploaded.keys())[0]  # Automatically get the file name
df = pd.read_csv(file_name)

# Check the DataFrame
print("DataFrame Shape:", df.shape)
print("First few rows of the DataFrame:")
print(df.head())

# Check the data types of the relevant columns
print(df[['likes', 'comments', 'followers']].dtypes)

# Convert likes, comments, and followers to numeric
df['likes'] = pd.to_numeric(df['likes'], errors='coerce')
df['comments'] = pd.to_numeric(df['comments'], errors='coerce')
df['followers'] = pd.to_numeric(df['followers'], errors='coerce')

# Check for any NaN values after conversion
print("NaN values in likes, comments, or followers:")
print(df[['likes', 'comments', 'followers']].isna().sum())

#Fill NaN values with 0
df.fillna(0, inplace=True)

# Check the DataFrame again
print("DataFrame after handling NaN values:")
print(df[['likes', 'comments', 'followers']].head())

# Step 2: Feature Engineering

# 1. Create engagement rate
df['engagement_rate'] = (df['likes'] + df['comments']) / df['followers']

# 2. Create caption length
df['caption_length'] = df['caption'].apply(lambda x: len(x) if isinstance(x, str) else 0)

# 3. Create content type based on whether it is a video or not
df['content_type'] = df['is_video'].apply(lambda x: 'video' if x else 'image')

# Display the updated DataFrame with new features
print("Updated DataFrame with new features:")
print(df[['engagement_rate', 'caption_length', 'content_type']].head())

# Step 2: Feature Engineering with Niche Indicator

# Define the keywords for each niche
niche_keywords = {
    'makeup': ['makeup', 'cosmetics', 'beauty', 'glam', 'brush', 'foundation', 'highlighter', 'lipstick', 'skincare', 'blush', 'eyeshadow', 'contour', 'lashes'],
    'fitness': ['fitness', 'gym', 'workout', 'exercise', 'health', 'wellness', 'yoga', 'cardio', 'weights', 'bodygoals', 'fitspo', 'healthy', 'strong', 'run'],
    'fashion': ['fashion', 'style', 'outfit', 'ootd', 'clothing', 'apparel', 'trend', 'chic', 'hair', 'accessories', 'wardrobe', 'runway', 'streetwear', 'vintage'],
    'food': ['coffee', 'food', 'recipe', 'cooking', 'baking', 'dinner', 'lunch', 'brunch', 'breakfast', 'dessert', 'snacks', 'wine', 'tea', 'foodie', 'yum'],
    'travel': ['travel', 'trip', 'vacation', 'explore', 'adventure', 'wanderlust', 'passport', 'journey', 'escape', 'landscape', 'scenic', 'beach', 'mountains', 'memories', 'bucketlist'],
    'technology': ['tech', 'gadget', 'software', 'device', 'innovation', 'digital', 'smart', 'AI', 'coding', 'geek', 'electronics', 'trends', 'gaming', 'apps', 'review'],
    'read': ['book', 'read', 'library', 'study', 'learning', 'knowledge', 'literature', 'poetry', 'chapter', 'write', 'mindset', 'wisdom', 'words'],
    'lifestyle': ['lifestyle', 'home', 'decor', 'DIY', 'minimalism', 'aesthetic', 'cozy', 'interior', 'routine', 'selfcare', 'hygge', 'organization', 'vibes', 'chill', 'special'],
    'family': ['parenting', 'mom', 'dad', 'children', 'family', 'siblings', 'bond', 'baby', 'kids', 'grandparents', 'love', 'happiness', 'home', 'nurture', 'play'],
    'pets': ['pet', 'dog', 'cat', 'animal', 'cute', 'puppy', 'kitten', 'paw', 'rescue', 'adoption', 'love', 'furry', 'friend', 'wildlife', 'petcare'],
    'art': ['art', 'painting', 'drawing', 'illustration', 'creative', 'design', 'craft', 'sketch', 'imagination', 'artist', 'color', 'gallery', 'doodle', 'abstract'],
    'motivation': ['motivation', 'inspiration', 'goals', 'mindset', 'dream', 'positivity', 'success', 'hustle', 'gratitude', 'growth'],
    'gaming': ['gaming', 'gamer', 'play', 'videogame', 'stream', 'esports', 'console', 'PC', 'gameplay', 'arcade', 'levelup', 'tournament', 'multiplayer'],
    'events': ['event', 'party', 'celebration', 'wedding', 'birthday', 'anniversary', 'festival', 'concert', 'gathering', 'occasion', 'fun', 'decorations'],
    'music': ['music', 'song', 'playlist', 'artist', 'band', 'concert', 'dance', 'melody', 'lyrics', 'album', 'beat', 'DJ', 'tune', 'performance', 'sound'],
    'sports': ['sports', 'team', 'game', 'soccer', 'basketball', 'football', 'baseball', 'tennis', 'goal', 'win', 'athlete', 'training', 'match', 'fans', 'score'],
    'cars': ['car', 'automobile', 'vehicle', 'drive', 'racing', 'luxury', 'engine', 'roadtrip', 'speed', 'garage', 'offroad', 'classic', 'ride', 'wheels', 'adventure'],
    'movies': ['movie', 'film', 'cinema', 'hollywood', 'bollywood', 'actor', 'director', 'scene', 'review', 'popcorn', 'theater', 'trailer', 'series', 'story'],
    'photography': ['photography', 'photo', 'camera', 'lens', 'capture', 'portrait', 'landscape', 'snap', 'editing', 'shutter', 'focus', 'studio', 'gallery', 'filters'],
    'entrepreneurship': ['business', 'entrepreneur', 'startup', 'marketing', 'hustle', 'strategy', 'network', 'goals', 'innovation', 'teamwork', 'leadership', 'success', 'motivation', 'wealth'],
    'nature': ['nature', 'outdoors', 'forest', 'wildlife', 'green', 'hiking', 'adventure', 'scenic', 'mountains', 'river', 'landscape', 'peaceful', 'environment', 'flora', 'fauna'],
    'relationships': ['love', 'relationship', 'couple', 'romance', 'friendship', 'bond', 'connection', 'feelings', 'dating', 'partner', 'support', 'family', 'together'],
    'education': ['education', 'learning', 'school', 'study', 'college', 'university', 'knowledge', 'teacher', 'student', 'classroom', 'lesson', 'skills', 'growth'],
    'quotes': ['quote', 'quotes', 'inspiration', 'words', 'mindset', 'motivation', 'success', 'positivity', 'wisdom', 'proverbs', 'writing', 'thought', 'expression', 'creativity']
}

# Function to determine the niche based on keywords in the caption
def classify_niche(caption):
    if isinstance(caption, str):
        caption_lower = caption.lower()  # Convert to lowercase for matching
        for niche, keywords in niche_keywords.items():
            if any(keyword in caption_lower for keyword in keywords):
                return niche

# Create the niche indicator column
df['niche'] = df['caption'].apply(classify_niche)

# Display the updated DataFrame with the new niche column
print("Updated DataFrame with Niche Indicator:")
print(df[['caption', 'niche']].head())

print("Number of None or NaN values in 'niche':", df['niche'].isnull().sum())

df = df.dropna(subset=['niche'])

from sklearn.model_selection import train_test_split

# Step 3: Prepare the Data

# Define the features (X) and the target variable (y)
X = df[['engagement_rate', 'caption_length', 'likes', 'comments']]  # Features
y = df['niche']  # Target variable (niche indicator)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# Display the shapes of the train and test sets
print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)
print("y_train shape:", y_train.shape)
print("y_test shape:", y_test.shape)

# Check for NaN values in X_train
print("NaN values in X_train:")
print(X_train.isna().sum())

import numpy as np
# Check for infinite values in X_train
print("\nInfinite values in X_train:")
print(np.isinf(X_train).sum())

# Option 1: Fill NaN values with 0
X_train.fillna(0, inplace=True)

# Option 2: Drop rows with NaN values
# X_train.dropna(inplace=True)

# Handle infinite values
X_train.replace([np.inf, -np.inf], 0, inplace=True)  # Replace infinite values with 0

# Repeat the same for X_test
X_test.fillna(0, inplace=True)
X_test.replace([np.inf, -np.inf], 0, inplace=True)

# Check again for NaN and infinite values
print("NaN values in X_train after handling:")
print(X_train.isna().sum())
print("Infinite values in X_train after handling:")
print(np.isinf(X_train).sum())

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

# Step 4: Train the Model

# Initialize the Random Forest Classifier
model = RandomForestClassifier(random_state=42)

# Fit the model to the training data
model.fit(X_train, y_train)

# Step 5: Make Predictions
y_pred = model.predict(X_test)

# Step 6: Evaluate the Model
print("Confusion Matrix:")
print(confusion_matrix(y_test, y_pred))

print("\nClassification Report:")
print(classification_report(y_test, y_pred))

print("Accuracy Score:", accuracy_score(y_test, y_pred))

# Create a sample new data point with all required features
new_data = pd.DataFrame({
    'engagement_rate': [0.05],  # Example engagement rate
    'caption_length': [120],      # Example caption length
    'likes': [100],               # Example likes
    'comments': [10]              # Example comments
})

# Make predictions
predicted_content_type = model.predict(new_data)
print("Predicted content type for the new data:", predicted_content_type[0])

import pandas as pd
import numpy as np

# Generate synthetic test data
synthetic_data = pd.DataFrame({
    'engagement_rate': np.random.uniform(0, 1, 100),  # Random engagement rates between 0 and 1
    'caption_length': np.random.randint(0, 300, 100),  # Random caption lengths between 0 and 300
    'likes': np.random.randint(0, 1000, 100),          # Random likes between 0 and 1000
    'comments': np.random.randint(0, 100, 100)         # Random comments between 0 and 100
})

# Make predictions on synthetic data
predictions = model.predict(synthetic_data)
print(predictions)

import matplotlib.pyplot as plt

# Assuming y_train is your target variable
plt.figure(figsize=(10, 6))
y_train.value_counts().plot(kind='bar')
plt.title('Class Distribution in Training Data')
plt.xlabel('Niche')
plt.ylabel('Count')
plt.show()